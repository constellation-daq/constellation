#!/usr/bin/env python3
"""This module provides a base class for a Constellation Satellite."""

import yaml
import time
import datetime
import sys
import logging

from .datasender import DataSender, DataBlock
from .rpdevice import RedPitaya250_14_4CH

from .protocol import ServiceIdentifier

version = "0.0.1"  # TODO this should be auto-generated by setup.py


class RedPitayaSatellite(DataSender):
    """Constellation Satellite to control a Keithley2410."""

    def __init__(
        self, name, cmd_port, hb_port, log_port, data_port, config_file, sampling_period
    ):
        super().__init__(
            name=name,
            cmd_port=cmd_port,
            hb_port=hb_port,
            log_port=log_port,
            data_port=data_port,
        )
        self.sampling_period = sampling_period
        self.config_file = config_file

        with open(self.config_file, "r") as configFile:
            self.yaml_config = yaml.safe_load(configFile)

        self.broadcast_manager.register_service(data_port, ServiceIdentifier.DATA)
        self.logger.info("Satellite broadcasting DATA service")
        # self.current_publish_interval = self.yaml_config["CurrentPublish"]["Interval"]

    def on_initialize(self):
        self.logger.info(
            "Loading RedPitaya configuration file " + self.config_file + ".",
        )
        self.device = RedPitaya250_14_4CH(self.yaml_config)

    def on_deinitialize(self):
        """Callback method for the 'deinitialize' transition of the FSM.

        Undo actions from 'on_initialize'
        """
        # Unload config, reset everything to default
        self.logger.info("Resetting and removing RedPitaya device.")
        self.device.disconnect()
        self.device = None
        # self.current_stat_thread = None

    def on_launch(self):
        """Callback method for the 'prepare' transition of the FSM."""
        super().on_launch()
        # Ramp up, and already here start logging currents, really.
        self.logger.info("Launching RedPitaya satellite. Activating ACQ.")

        # Note:
        # Before any settings are changed, the data acquisition from the device needs to be paused
        # (as we can't have two processes writing to the Keithley at the same time).
        # Pausing can be done by calling disable_acquisition(), unpausing by calling enable_acquisition().

        # self.device.disable_acquisition()
        # [Change settings here]
        # self.device.enable_acquisition()

        """
        # Start publishing the current
        self.publish_current = True
        self.current_stat_thread = threading.Thread(target=self.pub_current_stat, args=(self.current_publish_interval,))
        self.current_stat_thread.start()
        """

    def on_land(self):
        """Callback method for the 'unprepare' transition of the FSM."""
        super().on_land()
        # Ramp down, stop publishing currents
        self.logger.info("Landing Red Pitaya satellite.")

        """ # Stop current-publishing thread
        self.publish_current = False
        if self.current_stat_thread.is_alive():
            self.current_stat_thread.join() """

    def on_start(self):
        """Callback method for the 'start_run' transition of the FSM.

        This method needs to start acquisition on a new thread.
        """
        super().on_start()

    def on_stop(self):
        """Callback method for the 'stop_run' transition of the FSM.

        This method needs to the stop acquisition on the other thread.
        """
        super().on_stop()

    def do_run(self):
        num = 0
        total_data = 0

        self.logger.info("Red Pitaya satellite running, publishing events.")
        t0 = time.time()

        self.device.enable_acquisition()  # Should maybe be moved to on_launch and run whole data acq process on separate thread
        self.device.initialize_readpointer()

        time.sleep(self.sampling_period)

        while not self._stop_running.is_set():
            payload = self.device.get_data()
            meta = {
                "eventid": num,
                "time": datetime.datetime.now().isoformat(),
                "dtype": f"{payload.dtype}",
                "islast": False,
            }
            data = DataBlock(payload.tobytes(), meta)
            self.data_queue.put(data)
            self.logger.debug(f"Queueing data packet {num}")
            num += 1
            total_data += sys.getsizeof(payload)
            time.sleep(self.sampling_period)

        self.device.disable_acquisition()
        # Shutdown TODO: Find a less cluttered way of doing this
        meta = {
            "eventid": num,
            "time": datetime.datetime.now().isoformat(),
            "dtype": f"{payload.dtype}",
            "islast": True,
        }
        data = DataBlock(bytes([0, 0]), meta)
        self.data_queue.put(data)
        self.logger.debug(f"Queueing last data packet {num}")

        t1 = time.time()
        self.logger.info(
            f"total time for {num} evt / {num * len(payload) / 1024 / 1024}MB: {t1 - t0}s"
        )

    def on_failure(self):
        """Callback method for the 'on_failure' transition of the FSM."""
        super().on_failure()
        self.logger.error("Red Pitaya satellite failed.")
        """ # Stop current-publishing thread
        self.publish_current = False
        if self.current_stat_thread.is_alive():
            self.current_stat_thread.join()
        """

    def on_interrupt(self):
        """Callback method for the 'on_interrupt' transition of the FSM."""
        super().on_interrupt()
        self.logger.warning("Red Pitaya satellite interrupted.")
        """ # Stop current-publishing thread
        self.publish_current = False
        if self.current_stat_thread.is_alive():
            self.current_stat_thread.join() """

    def on_recover(self):
        """Callback method for the 'on_recover' transition of the FSM."""
        super().on_recover()

    def on_reset(self):
        """Callback method for the 'on_reset' transition of the FSM."""
        self.logger.info("Resetting and removing Red Pitaya device.")
        self.device.disconnect()

    """ # Publishes the current reading
    def pub_current_stat(self, interval):
        while self.publish_current:
            self.logstatspub.sendStats("CURRENT", eddaEnums.DataType.FLOAT, self.device.get_current()[0])
            time.sleep(interval) """


# -------------------------------------------------------------------------


def main(args=None):
    import argparse

    parser = argparse.ArgumentParser()
    parser.add_argument("--log-level", default="info")
    parser.add_argument("--cmd-port", type=int, default=23999)
    parser.add_argument("--log-port", type=int, default=55556)
    parser.add_argument("--hb-port", type=int, default=61234)
    parser.add_argument("--data-port", type=int, default=55557)
    parser.add_argument(
        "--config-file",
        type=str,
        default="./python/constellation/config_redpitaya_measure_events_standard.yaml",
    )
    parser.add_argument("--sampling-period", type=float, default=0.1)

    args = parser.parse_args(args)
    logging.basicConfig(
        format="%(asctime)s %(levelname)s %(name)s: %(message)s",
        level=args.log_level.upper(),
    )

    # start server with remaining args
    s = RedPitayaSatellite(
        name="RedPitaya_data_sender",
        cmd_port=args.cmd_port,
        hb_port=args.hb_port,
        log_port=args.log_port,
        data_port=args.data_port,
        config_file=args.config_file,
        sampling_period=args.sampling_period,
    )

    # start server with remaining args
    try:
        s.run_satellite()
    except KeyboardInterrupt:
        s.on_interrupt()


if __name__ == "__main__":
    main()
